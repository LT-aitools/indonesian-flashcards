// Function to get upcoming words for debug display
        function getUpcomingWordsDebug(count) {
            // Create a copy of vocabulary for sorting
            const upcomingWords = [...vocabulary];
            
            // Skip current word
            let startIdx = currentWordIndex + 1;
            if (startIdx >= upcomingWords.length) startIdx = 0;
            
            // Sort by priority score
            upcomingWords.forEach(word => {
                const wordKey = `${word.english}:${word.indonesian}`;
                const stats = wordStats[wordKey];
                const importanceScore = (6 - stats.importance) * 10;
                const reviewScore = stats.nextReviewCount - globalWordCounter;
                
                let priorityScore = reviewScore;
                if (reviewScore <= 0) {
                    priorityScore = importanceScore;
                } else {
                    const importanceFactor = 1 - ((stats.importance - 1) * 0.15);
                    priorityScore = reviewScore * importanceFactor;
                }
                stats.priorityScore = priorityScore;
            });
            
            upcomingWords.sort((a, b) => {
                const keyA = `${a.english}:${a.indonesian}`;
                const keyB = `${b.english}:${b.indonesian}`;
                const scoreA = wordStats[keyA].priorityScore;
                const scoreB = wordStats[keyB].priorityScore;
                return scoreA - scoreB;
            });
            
            // Create debug text for upcoming words
            let debugText = '';
            let counter = 0;
            let i = 0;
            let displayedWords = 0;
            
            while (displayedWords < count && i < upcomingWords.length) {
                const word = upcomingWords[i];
                const wordKey = `${word.english}:${word.indonesian}`;
                const stats = wordStats[wordKey];
                
                // Skip current word
                if (word.english === vocabulary[currentWordIndex].english &&
                    word.indonesian === vocabulary[currentWordIndex].indonesian) {
                    i++;
                    continue;
                }
                
                // Check if word is due for review
                if (stats.nextReviewCount && stats.nextReviewCount > globalWordCounter) {
                    const dueIn = stats.nextReviewCount - globalWordCounter;
                    debugText += `${displayedWords + 1}. "${word.english}" - due in ${dueIn} words (importance: ${stats.importance})<br>`;
                } else {
                    debugText += `${displayedWords + 1}. "${word.english}" - due now (importance: ${stats.importance})<br>`;
                }
                
                displayedWords++;
                i++;
            }
            
            return debugText;
        }<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indonesian Flashcards</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <style>
/* Remove background from body */
/* Ensure body is structured properly */
body {
    font-family: Arial, sans-serif;
    text-align: center;
    margin: 0; /* Remove margin to prevent misalignment */
    height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

/* Background image div */
.background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: url('images/background.jpeg') no-repeat center center fixed;
    background-size: cover;
    opacity: 0.2; /* Adjusted to give the whitewashed effect */
    z-index: -1;
}

/* Ensure content stays above the background */
#content {
    position: relative;
    z-index: 1;
    background: rgba(255, 255, 255, 0.8); /* Optional: Helps readability */
    padding: 20px;
    border-radius: 10px;
}

        
        button {
            margin: 10px;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
        }
        #correct {
            background-color: lightgreen;
            background-color: lightgreen;
        }
        #sorta {
            background-color: lightsalmon; /* Light orange */
        }
        #incorrect {
            background-color: lightcoral;
        }
        #reveal {
            background-color: yellow;
        }
        #correct, #sorta, #incorrect, #example {
            display: none;
        }
        #answer {
            color: green;
            font-size: 20px;
            margin-top: 10px;
        }
        #exampleSentence {
            color: blue;
            font-size: 18px;
            margin-top: 10px;
        }
        #stats {
            margin-top: 15px;
            font-size: 14px;
            color: #666;
        }
        #debugInfo {
            margin-top: 5px;
            font-size: 12px;
            color: #999;
            border-top: 1px dashed #ccc;
            padding-top: 5px;
            text-align: left;
        }
    </style>
</head>
<body>
    <div class="background"></div> <!-- Background image -->
    <div id="content">
        <h1 style="color: darkgrey; margin-bottom: 20px;">Indonesian Flashcard Game</h1>
        <h2 id="question">Loading...</h2>
        <h3 id="answer"></h3>
        <h3 id="exampleSentence"></h3>
        <button id="hint1">Hint 1</button>
        <button id="hint2">Hint 2</button>
        <button id="reveal">Reveal üëÄ</button>
        <br>
        <button id="correct" style="display: none;">Correct ‚úÖ</button>
        <button id="sorta" style="display: none; background-color: lightorange;">Sorta ü´§</button>
        <button id="incorrect" style="display: none;">Incorrect ‚ùå</button>
        <button id="example" style="display: none;">Example</button>
        <div id="stats"></div>
        <div id="debugInfo" style="display: none;"></div>
    </div>
    <!-- Back to Main Button -->
    <a href="https://lt-aitools.github.io/indonesian-flashcards/"
        style="display: inline-block; margin-top: 20px; text-decoration: none; 
                background-color: lightblue; padding: 10px 20px; border-radius: 5px;">
        Back to Main
    </a>

    <script>
        const vocabulary = [];
        let currentWordIndex = 0;
        
        // Spaced repetition system data structure
        let wordStats = {};
        
        // Constants for spaced repetition - words to see before showing again
        const CORRECT_INTERVAL = 50; // Show this word again after 50 other words
        const SORTA_INTERVAL = 20;   // Show this word again after 20 other words
        const INCORRECT_INTERVAL = 10; // Show this word again after 10 other words
        
        // Global counter for words seen in the session
        let globalWordCounter = 0;
        
        // Debug mode for checking spaced repetition
        const DEBUG_MODE = true; // Set to false to disable debug info
        
        // Load word stats from localStorage
        function loadWordStats() {
            const savedStats = localStorage.getItem('indonesianFlashcardStats');
            if (savedStats) {
                wordStats = JSON.parse(savedStats);
            }
        }
        
        // Save word stats to localStorage
        function saveWordStats() {
            localStorage.setItem('indonesianFlashcardStats', JSON.stringify(wordStats));
        }

        // Load CSV Data
        async function loadCSV() {
            console.log('Attempting to load CSV...');
            const response = await fetch("https://raw.githubusercontent.com/LT-aitools/indonesian-flashcards/refs/heads/main/Indonesian_vocabulary.csv"); // Replace with actual path
            const data = await response.text();
            parseCSV(data);
        }

        // Parse CSV and store words
        function parseCSV(data) {
            const rows = data.split('\n').map(row => row.split(','));
            rows.shift(); // Remove headers
            rows.forEach(row => {
                // Add the importance weight from column G (index 6)
                const importanceWeight = row[6] ? parseInt(row[6]) : 3; // Default to 3 if missing
                
                vocabulary.push({
                    english: row[1],
                    indonesian: row[2],
                    exampleSentence: row[3], // Column 4 (Example Sentence Combined)
                    importance: importanceWeight // Add importance weight
                });
            });
            
            // Load saved word stats
            loadWordStats();
            
            // Initialize stats for new words
            vocabulary.forEach(word => {
                const wordKey = `${word.english}:${word.indonesian}`;
                if (!wordStats[wordKey]) {
                    wordStats[wordKey] = {
                        correctCount: 0,
                        sortaCount: 0,
                        incorrectCount: 0,
                        lastSeenCount: 0,
                        nextReviewCount: 0, // 0 means ready to be shown
                        importance: word.importance || 3, // Store importance in stats
                        level: 1
                    };
                } else {
                    // Update importance in case it changed in the CSV
                    wordStats[wordKey].importance = word.importance || wordStats[wordKey].importance;
                }
            });
            
            startGame();
        }

        // Shuffle and start game
        function startGame() {
            // First, assign scores to each word based on importance and next review count
            vocabulary.forEach(word => {
                const wordKey = `${word.english}:${word.indonesian}`;
                const stats = wordStats[wordKey];
                const importanceScore = (6 - stats.importance) * 10; // Invert so 5 is lowest score (highest priority)
                const reviewScore = stats.nextReviewCount - globalWordCounter;
                
                // Calculate priority score - lower is higher priority
                // Words past due (negative reviewScore) get highest priority
                let priorityScore = reviewScore;
                
                // If the word is due for review (reviewScore <= 0), prioritize by importance
                if (reviewScore <= 0) {
                    priorityScore = importanceScore;
                } else {
                    // For words not yet due, adjust their priority based on importance
                    // More important words (higher weight) get lower interval multipliers
                    const importanceFactor = 1 - ((stats.importance - 1) * 0.15); // 1.0 to 0.4 factor
                    priorityScore = reviewScore * importanceFactor;
                }
                
                // Store the priority score for sorting
                stats.priorityScore = priorityScore;
            });
            
            // Sort by priority score (lower is higher priority)
            vocabulary.sort((a, b) => {
                const keyA = `${a.english}:${a.indonesian}`;
                const keyB = `${b.english}:${b.indonesian}`;
                const scoreA = wordStats[keyA].priorityScore;
                const scoreB = wordStats[keyB].priorityScore;
                return scoreA - scoreB;
            });
            
            showNextWord();
        }

        // Display next word
        function showNextWord() {
            if (currentWordIndex >= vocabulary.length) {
                // Reset if we've gone through all words
                currentWordIndex = 0;
                startGame();
                return;
            }
            
            const word = vocabulary[currentWordIndex];
            if (!word) return;
            
            // Get current word stats
            const wordKey = `${word.english}:${word.indonesian}`;
            const stats = wordStats[wordKey];
            
            // Check if it's time to review this word
            if (stats.nextReviewCount && stats.nextReviewCount > globalWordCounter) {
                // Skip this word if it's not time to review yet
                currentWordIndex++;
                showNextWord();
                return;
            }
            
            // Update last seen counter
            stats.lastSeenCount = globalWordCounter;
            // Increment global counter for each word shown
            globalWordCounter++;
            saveWordStats();
            
            // Display word
            speakWord(word.english, 'en-US');
            
            document.getElementById('question').innerText = word.english;
            document.getElementById('answer').innerText = "";
            document.getElementById('exampleSentence').innerText = "";
            document.getElementById('hint1').style.display = 'inline';
            document.getElementById('hint2').style.display = 'inline';
            document.getElementById('hint1').innerText = "Hint 1";
            document.getElementById('hint2').innerText = "Hint 2";
            document.getElementById('reveal').style.display = 'inline';
            document.getElementById('example').style.display = 'none';
            document.getElementById('correct').style.display = 'none';
            document.getElementById('sorta').style.display = 'none';
            document.getElementById('incorrect').style.display = 'none';
            
            // Hide stats initially
            document.getElementById('stats').innerHTML = '';
            
            document.getElementById('hint1').onclick = () => showHint(1);
            document.getElementById('hint2').onclick = () => showHint(2);
            document.getElementById('reveal').onclick = revealAnswer;
            document.getElementById('example').onclick = showExample;
            document.getElementById('correct').onclick = markCorrect;
            document.getElementById('sorta').onclick = markSorta;
            document.getElementById('incorrect').onclick = markIncorrect;
        }

        // Hints and Reveal
        function showHint(level) {
            const word = vocabulary[currentWordIndex];
            if (level === 1) {
                document.getElementById('hint1').innerText = `First letter: ${word.indonesian.charAt(0)}`;
            } else if (level === 2) {
                document.getElementById('hint2').innerText = `Hint: ${word.indonesian.charAt(0)}${'-'.repeat(word.indonesian.length - 1)}`;
            }
        }

        function revealAnswer() {
            const word = vocabulary[currentWordIndex];
            const wordKey = `${word.english}:${word.indonesian}`;
            const stats = wordStats[wordKey];
            
            speakWord(word.indonesian, 'id-ID');
            document.getElementById('answer').innerText = word.indonesian;
            document.getElementById('hint1').style.display = 'none';
            document.getElementById('hint2').style.display = 'none';
            document.getElementById('reveal').style.display = 'none';
            document.getElementById('example').style.display = 'inline';
            document.getElementById('correct').style.display = 'inline';
            document.getElementById('sorta').style.display = 'inline';
            document.getElementById('incorrect').style.display = 'inline';
            
            // Now show stats after revealing the answer
            updateStatsDisplay(wordKey);
            
            // Show debug info if debug mode is on
            if (DEBUG_MODE) {
                const debugDiv = document.getElementById('debugInfo');
                debugDiv.style.display = 'block';
                
                // Calculate next review counts for each response type
                const correctNextReview = globalWordCounter + Math.round(CORRECT_INTERVAL * (1.5 - (stats.importance * 0.1)));
                const sortaNextReview = globalWordCounter + Math.round(SORTA_INTERVAL * (1.5 - (stats.importance * 0.1)));
                const incorrectNextReview = globalWordCounter + Math.round(INCORRECT_INTERVAL * (1.5 - (stats.importance * 0.1)));
                
                // Generate debug text
                debugDiv.innerHTML = `
                    <strong>Spaced Repetition Debug Info</strong><br>
                    Global Word Counter: ${globalWordCounter}<br>
                    This word's importance: ${stats.importance}/5<br>
                    Last seen at counter: ${stats.lastSeenCount || 'Never'}<br>
                    Scheduled next review at counter: ${stats.nextReviewCount || 'First review'}<br>
                    Words seen since last review: ${globalWordCounter - (stats.lastSeenCount || 0)}<br>
                    <br>
                    If marked "Correct": Next review after ${correctNextReview - globalWordCounter} more words<br>
                    If marked "Sorta": Next review after ${sortaNextReview - globalWordCounter} more words<br>
                    If marked "Incorrect": Next review after ${incorrectNextReview - globalWordCounter} more words<br>
                    <br>
                    <em>Upcoming words in queue (next 5):</em><br>
                    ${getUpcomingWordsDebug(5)}
                `;
            }
        }

        function showExample() {
            const word = vocabulary[currentWordIndex];
            speakWord(word.exampleSentence, 'id-ID');
            document.getElementById('exampleSentence').innerText = word.exampleSentence;
            document.getElementById('example').style.display = 'inline';
        }

        // Track progress with spaced repetition
        function markCorrect() {
            const word = vocabulary[currentWordIndex];
            const wordKey = `${word.english}:${word.indonesian}`;
            const stats = wordStats[wordKey];
            
            // Update stats
            stats.correctCount++;
            
            // Set next review based on word count and importance
            // More important words (higher weight) get shorter intervals
            const importanceFactor = 1.5 - (stats.importance * 0.1); // Ranges from 1.0 to 0.5
            const adjustedInterval = Math.round(CORRECT_INTERVAL * importanceFactor);
            
            stats.nextReviewCount = globalWordCounter + adjustedInterval;
            
            saveWordStats();
            currentWordIndex++;
            showNextWord();
        }
        
        function markSorta() {
            const word = vocabulary[currentWordIndex];
            const wordKey = `${word.english}:${word.indonesian}`;
            const stats = wordStats[wordKey];
            
            // Update stats
            stats.sortaCount++;
            
            // Set next review based on word count and importance
            const importanceFactor = 1.5 - (stats.importance * 0.1); // Ranges from 1.0 to 0.5
            const adjustedInterval = Math.round(SORTA_INTERVAL * importanceFactor);
            
            stats.nextReviewCount = globalWordCounter + adjustedInterval;
            
            saveWordStats();
            currentWordIndex++;
            showNextWord();
        }

        function markIncorrect() {
            const word = vocabulary[currentWordIndex];
            const wordKey = `${word.english}:${word.indonesian}`;
            const stats = wordStats[wordKey];
            
            // Update stats
            stats.incorrectCount++;
            
            // Set next review based on word count and importance
            const importanceFactor = 1.5 - (stats.importance * 0.1); // Ranges from 1.0 to 0.5
            const adjustedInterval = Math.round(INCORRECT_INTERVAL * importanceFactor);
            
            stats.nextReviewCount = globalWordCounter + adjustedInterval;
            
            saveWordStats();
            currentWordIndex++;
            showNextWord();
        }
        
        // Display stats for current word
        function updateStatsDisplay(wordKey) {
            const stats = wordStats[wordKey];
            const statsElement = document.getElementById('stats');
            
            if (stats) {
                const totalReviews = stats.correctCount + stats.sortaCount + stats.incorrectCount;
                let accuracy = 0;
                if (totalReviews > 0) {
                    accuracy = Math.round((stats.correctCount / totalReviews) * 100);
                }
                
                let nextReviewIn = stats.nextReviewCount ? stats.nextReviewCount - globalWordCounter : 0;
                if (nextReviewIn < 0) nextReviewIn = 0;
                
                statsElement.innerHTML = `
                    Times seen: ${totalReviews} | 
                    Correct: ${stats.correctCount} | 
                    Sorta: ${stats.sortaCount} | 
                    Incorrect: ${stats.incorrectCount} | 
                    Accuracy: ${accuracy}%
                `;
            } else {
                statsElement.innerHTML = 'New word';
            }
        }

        // Shuffle helper function
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // Text-to-speech function
        function speakWord(word, lang) {
            if (word) {
                const utterance = new SpeechSynthesisUtterance(word);
                utterance.lang = lang;
                speechSynthesis.speak(utterance);
            }
        }

        // Add debug toggle button
        window.onload = function() {
            loadCSV();
            
            // Add button to toggle debug mode display
            const contentDiv = document.getElementById('content');
            const debugButton = document.createElement('button');
            debugButton.innerText = 'Toggle Debug Info';
            debugButton.style.fontSize = '12px';
            debugButton.style.padding = '5px';
            debugButton.style.marginTop = '15px';
            debugButton.style.backgroundColor = '#eee';
            debugButton.onclick = function() {
                const debugDiv = document.getElementById('debugInfo');
                if (debugDiv.style.display === 'none') {
                    debugDiv.style.display = 'block';
                } else {
                    debugDiv.style.display = 'none';
                }
            };
            
            contentDiv.appendChild(debugButton);
        };
    </script>
</body>
</html>